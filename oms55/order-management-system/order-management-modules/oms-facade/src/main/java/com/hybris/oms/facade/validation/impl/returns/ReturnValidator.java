/*
 * [y] hybris Platform
 *
 * Copyright (c) 2000-2015 hybris AG
 * All rights reserved.
 *
 * This software is the confidential and proprietary information of hybris
 * ("Confidential Information"). You shall not disclose such Confidential
 * Information and shall use it only in accordance with the terms of the
 * license agreement you entered into with hybris.
 *
 *  
 */
package com.hybris.oms.facade.validation.impl.returns;


import com.hybris.oms.domain.exception.EntityValidationException;
import com.hybris.oms.domain.returns.Return;
import com.hybris.oms.domain.returns.ReturnOrderLine;
import com.hybris.oms.domain.returns.ReturnPaymentInfo;
import com.hybris.oms.facade.validation.Failure;
import com.hybris.oms.facade.validation.FieldValidationType;
import com.hybris.oms.facade.validation.ValidationContext;
import com.hybris.oms.facade.validation.Validator;
import com.hybris.oms.facade.validation.field.FieldValidatorFactory;
import com.hybris.oms.facade.validation.impl.AbstractValidator;
import com.hybris.oms.service.managedobjects.order.OrderData;
import com.hybris.oms.service.managedobjects.returns.ReturnData;
import com.hybris.oms.service.managedobjects.shipment.ShipmentData;
import com.hybris.oms.service.managedobjects.types.QuantityVT;
import com.hybris.oms.service.order.OrderService;
import com.hybris.oms.service.returns.ReturnService;
import com.hybris.oms.service.returns.impl.DefaultReturnService;
import com.hybris.oms.service.shipment.ShipmentService;

import java.util.List;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Required;


public class ReturnValidator extends AbstractValidator<Return>
{
	private static final Logger LOG = LoggerFactory.getLogger(ReturnValidator.class);
	private Validator<ReturnOrderLine> returnOrderLineValidator;

	private Validator<ReturnPaymentInfo> returnPaymentInfoValidator;
	private OrderService orderService;
	private ShipmentService shipmentService;
	private List<ShipmentData> shipmentList;
	private ReturnService returnService;

	@Override
	protected void validateInternal(final ValidationContext context, final Return returnDto)
	{
		LOG.debug("Validating Return..");

		// All returns must link to an order
		FieldValidatorFactory.getStringFieldValidator(context).notBlank("Return.OrderId", returnDto.getOrderId());
		FieldValidatorFactory.getStringFieldValidator(context).notNull("Return.ShippingRefunded",
				String.valueOf(returnDto.getShippingRefunded()));

		// The returnReasonCode must be supported
		if (!returnService.getReturnReasonCodes().contains(returnDto.getReturnReasonCode()))
		{
			context.reportFailure(this.getClass().getName(), new Failure(FieldValidationType.INVALID, "Return.returnReasonCode",
					returnDto.getReturnReasonCode(), null, "the return reason code is not valid"));
		}

		// Validate there are Shipments generated by the order linked to the return
		this.validateShipmentExistence(returnDto, context);
		this.validateSubTotalQuantityNotZero(returnDto, context);
		// Validate items and their quantities
		this.validateReturnItems(returnDto, context);
		this.validateRefundableShippingCost(returnDto, context);
		// validate returnOrderLines
		FieldValidatorFactory.getGenericFieldValidator(context).validateCollection("Return.returnOrderLines",
				returnDto.getReturnOrderLines(), this.returnOrderLineValidator);

		FieldValidatorFactory.getGenericFieldValidator(context).notNull("Return.returnPaymentInfos",
				returnDto.getReturnPaymentInfos());

		FieldValidatorFactory.getGenericFieldValidator(context).notNull("Return.returnReasonCode", returnDto.getReturnReasonCode())
		.notNull("Return.returnReasonCode", returnDto.getReturnReasonCode());
	}

	protected void validateSubTotalQuantityNotZero(final Return returnDto, final ValidationContext context)
	{
		int subTotalQuantities = 0;
		for (final ReturnOrderLine rol : returnDto.getReturnOrderLines())
		{
			subTotalQuantities += rol.getQuantity().getValue();
		}
		if (subTotalQuantities == 0)
		{
			context.reportFailure(this.getClass().getName(), new Failure(FieldValidationType.INVALID, "Return.returnOrderLines",
					"0", null, "for Return id: " + returnDto.getReturnId()
					+ " At least one of returned lines should have a quantity that is greater than zero"));

		}
	}

	protected void validateShipmentExistence(final Return returnDto, final ValidationContext context)
	{
		final OrderData orderData = orderService.getOrderByOrderId(returnDto.getOrderId());
		shipmentList = this.shipmentService.findShipmentsByOrder(orderData);
		if (shipmentList == null || shipmentList.isEmpty())
		{
			context.reportFailure(this.getClass().getName(), new Failure(FieldValidationType.INVALID, "Return.orderId", "0", null,
					"We don't detect any Shipment for order id: " + returnDto.getOrderId()));
		}
	}

	/**
	 * Validates if previously refunded shipping cost
	 *
	 * @param returnDto
	 * @param context
	 * @throws EntityValidationException
	 */
	protected void validateRefundableShippingCost(final Return returnDto, final ValidationContext context)
	{
		final ReturnData returnData = returnDto.getReturnId() == null ? null : returnService.findReturnById(Long.valueOf(returnDto
				.getReturnId()));
		final OrderData order = orderService.getOrderByOrderId(returnDto.getOrderId());
		if (returnService.shippingPreviouslyRefunded(returnData, order) && returnDto.getShippingRefunded())
		{
			context.reportFailure(this.getClass().getName(), new Failure(FieldValidationType.INVALID, "Return.shippingRefunded",
					"0", null, "You have already Refunded shipping cost for order Id:" + returnDto.getOrderId()
					+ " please change the property shippingRefunded to false."));
		}
	}

	/**
	 * Check the existence of the return items and their quantities in the shipped items.
	 *
	 * @param returnDto
	 * @param context
	 */
	protected void validateReturnItems(final Return returnDto, final ValidationContext context)
	{
		for (final ReturnOrderLine rol : returnDto.getReturnOrderLines())
		{
			ReturnData returnData = null;
			if (returnDto.getReturnId() != null)
			{
				returnData = returnService.findReturnById(Long.valueOf(returnDto.getReturnId()));
			}
			final OrderData order = orderService.getOrderByOrderId(returnDto.getOrderId());

			final QuantityVT returnableQuantity = returnService.getReturnableQuantity(returnData, order, rol.getOrderLine()
					.getOrderLineId(), rol.getOrderLine().getSkuId());

			if (rol.getQuantity().getValue() > 0 && returnableQuantity.getValue() == 0)
			{
				context.reportFailure(this.getClass().getName(), new Failure(FieldValidationType.INVALID, "Return.returnOrderLines",
						"0", null, "The sku you are trying to return was never bought or it has not been shipped to you yet!"));

			}
			else if (returnableQuantity.getValue() < rol.getQuantity().getValue())
			{
				context.reportFailure(this.getClass().getName(), new Failure(FieldValidationType.INVALID, "Return.returnOrderLines",
						"0", null, "You can't return the specified Quantity. Either it is not "
								+ "shipped to you yet or you already have returned it"));
			}
		}
	}

	@Required
	public void setReturnOrderLineValidator(final Validator<ReturnOrderLine> returnOrderLineValidator)
	{
		this.returnOrderLineValidator = returnOrderLineValidator;
	}

	@Required
	public void setReturnPaymentInfoValidator(final Validator<ReturnPaymentInfo> returnPaymentInfoValidator)
	{
		this.returnPaymentInfoValidator = returnPaymentInfoValidator;
	}

	@Required
	public void setOrderService(final OrderService orderService)
	{
		this.orderService = orderService;
	}

	@Required
	public void setShipmentService(final ShipmentService shipmentService)
	{
		this.shipmentService = shipmentService;
	}

	@Required
	public void setReturnService(final DefaultReturnService returnService)
	{
		this.returnService = returnService;
	}

	protected List<ShipmentData> getShipmentList()
	{
		return shipmentList;
	}

	protected void setShipmentList(final List<ShipmentData> shipmentList)
	{
		this.shipmentList = shipmentList;
	}
}
